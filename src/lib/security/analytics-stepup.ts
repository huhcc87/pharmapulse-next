/**
 * Analytics Step-Up Authentication
 *
 * Requires extra verification to access the Analytics Dashboard.
 * Even if a session token is stolen, sensitive analytics require step-up auth.
 */

import { prisma } from "@/lib/prisma";
import { generateAccessToken } from "@/lib/auth/jwt";
import crypto from "crypto";
import { StepUpMethod } from "@prisma/client";

const ANALYTICS_UNLOCK_DURATION_HOURS = 24;
const ANALYTICS_UNLOCK_DURATION_SECONDS = ANALYTICS_UNLOCK_DURATION_HOURS * 60 * 60;
const CHALLENGE_TTL_MINUTES = 10;

// Helper to normalize provided method string to StepUpMethod enum
function normalizeMethod(method: string): StepUpMethod {
  const m = method.toLowerCase();
  if (m === "email_otp") return StepUpMethod.MAGIC_LINK;   // treat email OTP as magic link/OTP
  if (m === "analytics_pin") return StepUpMethod.PASSWORD; // treat analytics PIN as PASSWORD
  if (m === "totp") return StepUpMethod.TOTP;
  // If method is already a valid StepUpMethod string (just different casing), match it
  const enumValues = Object.values(StepUpMethod).map((ev) => ev.toLowerCase());
  const idx = enumValues.indexOf(m);
  if (idx >= 0) return Object.values(StepUpMethod)[idx];
  throw new Error(`Unsupported step-up method: ${method}`);
}

/**
 * Determine if step-up is required for analytics.
 * For now, this can always return true (always require step-up), but you can add logic to skip 
 * if certain conditions are met (recent login, trusted device, etc.).
 */
export async function isAnalyticsStepUpRequired(
  tenantId: string,
  userId: string,
  userRole: string,
  sessionAgeHours: number,
  isNewDevice: boolean,
  ipChanged: boolean
): Promise<boolean> {
  // Example logic: require step-up if no active unlocked session exists
  const currentlyUnlocked = await prisma.stepUpSession.findFirst({
    where: {
      tenantId,
      userId,
      purpose: "analytics_unlock",
      unlockedUntil: { gt: new Date() }  // has an active unlock not expired
    }
  });
  if (currentlyUnlocked) {
    return false; // already unlocked
  }
  // You could incorporate role or other logic here. For now, default to require step-up.
  return true;
}

/**
 * Start a step-up challenge for analytics access.
 * This creates a StepUpSession entry with a challenge (OTP, etc.) and returns challenge details.
 */
export async function startAnalyticsStepUp(
  tenantId: string,
  userId: string,
  method: string = "email_otp",
  ipAddress?: string,
  userAgent?: string
) {
  const normalizedMethod = normalizeMethod(method);
  const now = new Date();

  // Generate a challenge identifier or code
  let challengeId: string | null = null;
  if (normalizedMethod === StepUpMethod.TOTP || normalizedMethod === StepUpMethod.PASSWORD) {
    // TOTP: we expect user to provide a code from their authenticator (no challenge code generated by server)
    // Password (PIN): user will provide their PIN, no server-generated code
    challengeId = crypto.randomBytes(16).toString("hex"); // an ID to track the attempt
  } else if (normalizedMethod === StepUpMethod.MAGIC_LINK) {
    // Email OTP/Magic link: generate a one-time code or token
    challengeId = crypto.randomBytes(3).toString("hex"); // e.g. 6-digit hex code (could be numeric or alphanumeric)
    // TODO: send this code to user's email in a real implementation
    console.log(`Sending email OTP code to user ${userId}: ${challengeId}`);
  }

  // Calculate challenge expiration
  const expiresAt = new Date(now.getTime() + CHALLENGE_TTL_MINUTES * 60_000);

  // Create a new step-up session (challenge entry)
  const session = await prisma.stepUpSession.create({
    data: {
      tenantId,
      userId,
      method: normalizedMethod,
      purpose: "general",           // "general" indicates an ongoing challenge
      challengeId: challengeId,
      expiresAt: expiresAt,
      ipAddress: ipAddress,
      userAgent: userAgent,
      // token and unlockedUntil remain null until verification success
    }
  });

  return {
    challengeId: session.challengeId,
    method: method,  // return the original requested method (or we can return normalizedMethod)
    expiresAt: session.expiresAt
  };
}

/**
 * Verify a step-up challenge code/PIN.
 * If successful, mark the session as verified and generate an unlock token.
 */
export async function verifyAnalyticsStepUp(
  challengeId: string,
  code: string,
  tenantId: string,
  userId: string
): Promise<{ success: boolean; token?: string; expiresAt?: Date }> {
  // Find the step-up session by the challengeId
  const session = await prisma.stepUpSession.findFirst({
    where: {
      tenantId,
      userId,
      challengeId: challengeId
    }
  });
  if (!session) {
    return { success: false }; // no such challenge
  }
  const now = new Date();
  // If challenge expired
  if (session.expiresAt < now) {
    return { success: false, token: undefined, expiresAt: undefined };
  }
  // If the challenge is locked due to too many failed attempts
  if (session.lockedUntil && session.lockedUntil > now) {
    return { success: false }; // locked out (could provide a specific message if needed)
  }

  // Verify the code or PIN:
  let valid = false;
  if (session.method === StepUpMethod.TOTP) {
    // Verify TOTP code using user's TOTP secret (not shown: fetch user's TOTP secret from DB or config)
    // e.g., valid = verifyTotpCode(user.totpSecret, code);
    valid = false; // (for now assume false as placeholder)
  } else if (session.method === StepUpMethod.PASSWORD) {
    // Verify PIN (password) - for analytics PIN, compare with stored hash or value.
    // (Assume we have the user's analytics PIN stored somewhere, or perhaps reuse their password.)
    // e.g., valid = compareHash(user.analyticsPinHash, code);
    valid = false; // TODO: implement actual PIN verification against stored PIN
  } else if (session.method === StepUpMethod.MAGIC_LINK) {
    // MAGIC_LINK / email OTP: the code should match the challengeId (or a stored code)
    if (session.challengeId && code.trim().toLowerCase() === session.challengeId.toLowerCase()) {
      valid = true;
    }
  }

  if (!valid) {
    // Increment failed attempts and possibly lock the challenge if too many failures
    const newFails = session.failedAttempts + 1;
    const updateData: any = { failedAttempts: newFails };
    if (newFails >= 5) {  // lock after 5 incorrect tries (for example)
      updateData.lockedUntil = new Date(now.getTime() + 15 * 60_000); // 15 min lock
    }
    await prisma.stepUpSession.update({
      where: { id: session.id },
      data: updateData
    });
    return { success: false };
  }

  // If code is valid:
  const unlockedUntil = new Date(now.getTime() + ANALYTICS_UNLOCK_DURATION_SECONDS * 1000);
  // Generate an analytics unlock token (JWT or random string)
  const unlockToken = generateAccessToken(tenantId, userId, ANALYTICS_UNLOCK_DURATION_SECONDS);
  // Mark session as verified and store the unlock token
  await prisma.stepUpSession.update({
    where: { id: session.id },
    data: {
      purpose: "analytics_unlock",   // repurpose this session record as an unlocked session
      verifiedAt: now,
      expiresAt: now,                // challenge is no longer valid; you could also keep for audit
      unlockedUntil: unlockedUntil,
      token: unlockToken,
      failedAttempts: 0,
      lockedUntil: null
    }
  });
  return { success: true, token: unlockToken, expiresAt: unlockedUntil };
}

/**
 * Check if a given analytics unlock token (or active unlock session) is valid.
 * Returns true if the user has an active unlocked session for analytics.
 */
export async function isAnalyticsUnlocked(
  tenantId: string,
  userId: string,
  token?: string
): Promise<boolean> {
  const now = new Date();
  const session = await prisma.stepUpSession.findFirst({
    where: {
      tenantId,
      userId,
      purpose: "analytics_unlock",
      unlockedUntil: { gt: now },
      ...(token ? { token: token } : {})  // if token is provided, match it
    }
  });
  return session !== null;
}

/**
 * Get the current analytics unlock token for a user, if one exists and is still valid.
 */
export async function getAnalyticsUnlockToken(
  tenantId: string,
  userId: string
): Promise<string | null> {
  const now = new Date();
  const session = await prisma.stepUpSession.findFirst({
    where: {
      tenantId,
      userId,
      purpose: "analytics_unlock",
      unlockedUntil: { gt: now }
    },
    orderBy: { unlockedUntil: "desc" }
  });
  return session ? session.token : null;
}
